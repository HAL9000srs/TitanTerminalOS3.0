import { Asset, INITIAL_ASSETS, PortfolioSnapshot, PortfolioInsight } from '../types';
import { supabase } from './supabase';

export const loadAssets = async (): Promise<Asset[]> => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    const { data, error } = await supabase
      .from('assets')
      .select('*')
      .eq('user_id', user.id);

    if (error) {
      console.error('Error loading assets:', error);
      return INITIAL_ASSETS;
    }
    
    // Return data or empty array
    return data || [];
  } catch (e) {
    console.error("Failed to load assets", e);
    return [];
  }
};

// NEW: Fetch history generated by n8n
export const getPortfolioHistory = async (days: number = 30): Promise<PortfolioSnapshot[]> => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    const { data, error } = await supabase
      .from('daily_snapshots')
      .select('*')
      .eq('user_id', user.id)
      .order('snapshot_date', { ascending: true }) // Oldest first for the chart
      .limit(days);

    if (error) {
      console.error('Error loading history:', error);
      return [];
    }
    
    return data || [];
  } catch (e) {
    console.error("Failed to load history", e);
    return [];
  }
};

// NEW: Fetch latest Titan Intelligence insight
export const getPortfolioInsights = async (limit: number = 1): Promise<PortfolioInsight[]> => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return [];

    const { data, error } = await supabase
      .from('portfolio_insights')
      .select('*')
      .eq('user_id', user.id)
      .order('created_at', { ascending: false })
      .limit(limit);

    if (error) {
      console.error('Error loading insights:', error);
      return [];
    }
    
    return data || [];
  } catch (e) {
    console.error("Failed to load insights", e);
    return [];
  }
};

export const saveAssets = async (assets: Asset[]): Promise<void> => {
  try {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) return;

    // 1. Delete assets that were removed from the UI (orphan cleanup)
    const { data: existing } = await supabase
      .from('assets')
      .select('id')
      .eq('user_id', user.id);

    const currentIds = new Set(assets.map(a => a.id));
    const orphanIds = (existing || []).filter(e => !currentIds.has(e.id)).map(e => e.id);

    if (orphanIds.length > 0) {
      await supabase.from('assets').delete().in('id', orphanIds);
    }

    // 2. Upsert current assets
    if (assets.length > 0) {
      const { error } = await supabase
        .from('assets')
        .upsert(
          assets.map(asset => ({
            ...asset,
            user_id: user.id
          }))
        );

      if (error) console.error('Error saving assets:', error);
    }
  } catch (e) {
    console.error("Failed to save assets", e);
  }
};

// Keep existing calculation logic (it's pure math, no DB changes needed)
export const calculateSummary = (assets: Asset[]) => {
  let totalValue = 0;
  let totalCost = 0;

  const typeMap = new Map<string, number>();

  assets.forEach(asset => {
    const value = asset.quantity * asset.currentPrice;
    const cost = asset.quantity * asset.avgPrice;
    totalValue += value;
    totalCost += cost;

    const currentTypeTotal = typeMap.get(asset.type) || 0;
    typeMap.set(asset.type, currentTypeTotal + value);
  });

  const totalGainLoss = totalValue - totalCost;
  const totalGainLossPercent = totalCost > 0 ? (totalGainLoss / totalCost) * 100 : 0;

  const allocation = Array.from(typeMap.entries()).map(([name, value]) => ({
    name,
    value
  }));

  return {
    totalValue,
    totalCost,
    totalGainLoss,
    totalGainLossPercent,
    allocation
  };
};